---
title: "Chess EDA"
format: html
bibliography: refs.bib
---


```{r setup}
#| include: false

knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(RcppRoll)
library(cmdstanr)
library(bayesplot)

theme_set(theme_bw())

```



## Data

We first wish to investigate the properties of the scraped data.

```{r}
#| warning: false

lichess_data <- readRDS("../rdata/lichess_pilot.RData")
```

We see that the vast majority of games in this dataset 
are Standard, with the regular rules, etc. Similarly, the most
commonly played time controls is 180+0,
which corresponds to 3 minute blitz games with no time increment.

Of standard games, we see that the majority are rated blitz and bullet games.
These correspond to randomly playing available players on the site 
at a time. This differs from tournaments, which make up a sizeable proportion
of standard games also.

```{r}
table(lichess_data$Variant)

head(sort(table(lichess_data$TimeControl), decreasing = TRUE))

## this looks to be seconds + incrememnt, makes the most sense 
## could just take common blitz formats, 3 mins and 5 mins,
## would be 50k games still

head(sort(table(lichess_data$Event), decreasing = TRUE))

lichess_data %>% filter(Variant == "Standard") %>% 
  group_by(Event) %>% 
  count() %>% 
  arrange(-n)

```



Get all games from a specific player in a specific format,
to see that `RatingDiff` tracks how
the rating changes. For the White/Black player based
on the result of the current game.

```{r}
lichess_data %>% filter(TimeControl == "180+0") %>% 
  filter(Event == "Rated Blitz game") %>% 
  arrange(UTCDate, UTCTime) %>% 
  mutate(peng_elo = ifelse(White == "penguingim1", WhiteElo, BlackElo)) %>% 
  mutate(peng_change = ifelse(White == "penguingim1", WhiteRatingDiff,
                              BlackRatingDiff)) %>% 
  select(UTCDate, UTCTime, peng_elo, peng_change) %>%
  mutate(peng_elo = as.numeric(peng_elo)) %>% 
  mutate(peng_change = as.numeric(peng_change)) %>% 
  mutate(ELO_change = peng_elo + peng_change) %>% 
  head(n = 10)

### so RatingDiff gives you the starting ELO for the next game

```

- Casual games don't change the rating, so do we want to remove them from 
the data entirely? Would likely have a different role in winner effects,
etc.

For all current analysis we will restrict to 1 minute rated bullet games,
the most commonly played format in this dataset, with 13k games compared
to 12k games of 30 second bullet and 12k games of 3 minute blitz.


```{r}
## get simpler data

simple_data <- lichess_data %>% 
  filter(Event %in% c("Rated Bullet game", "Rated Blitz game")) 

lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  group_by(TimeControl) %>% 
  count() %>% 
  arrange(-n)


bullet_60 <- lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  filter(TimeControl == "60+0")


# bullet_60

# head(sort(table(bullet_60$White), decreasing = TRUE), 20)

## have a few different players with good number of games
## get list of all players, fit some sort of model using all players
## who play enough games
```

The top 25 players all play at least 80 games in this format, and across 
all games in this format we see relatively few draws. This is unsurprising
as it it hard to end at a draw in these short time controls, when one player
can lose on time.

```{r}
head(sort(table(c(bullet_60$White, bullet_60$Black)), decreasing = TRUE), 25)

## top 25 players possibly enough then, consider all games they are involved
## in

table(bullet_60$Result)

```


## Multilevel Logistic Regression

Similar to @ding2021nhl, we wish to fit a multilevel logistic 
regression to see if we can identify individual 
effects for chess players in this data.

To do this, we will consider the current history of an individual player
as their win ratio in their past $n$ games, where we will investigate
the sensitivity of these results to different choices of $n$.

We will identify focal players as those who were used to query the API,
i.e the `Username` for each game. We only consider Rated 60 second bullet games
here.


```{r, past-n-results}
#| message: false

## given a players data, determine how many of the previous games they won
## do this for a single player first of all
## only need to do this for the potential focal players

curr_user <- "penguingim1"
curr_n <- 10

curr_games <- bullet_60 %>% 
  filter(White == curr_user | Black == curr_user)


hist_games <- curr_games %>% 
  arrange(UTCDate, UTCTime) %>% 
  mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
  select(White:BlackElo, focal_white)

## need to check all the game types are the same here then
table(curr_games$Variant)
table(curr_games$Result)

## then get the result for curr_user for each game, there will be draws here

user_games <- hist_games %>% 
  mutate(focal_result = case_when(
    (focal_white == 1 & Result == "1-0") ~ 1,
    (focal_white == 0 & Result == "0-1") ~ 1,
    (Result == "1/2-1/2") ~ 0.5,
    .default = 0
    )) %>% 
  mutate(focal_win_prop = c(rep(0, curr_n - 1), roll_mean(focal_result, n = curr_n)))

user_games %>% 
  ggplot(aes(x = focal_win_prop)) +
  geom_histogram(bins = 20) +
  labs(title = "Win Ratio for Previous 10 Games, one Player")

### now just need to get the rolling average of focal result
### need to pad this output

### could we do this using a map across the players of interest,
### get their games and then put it all back together afterwards?
### think that should work, just need to make it into a function then


get_hist <- function(user, games, prev_n) {
  hist_games <- games %>% 
    filter(White == user | Black == user) %>% 
    arrange(UTCDate, UTCTime) %>% 
    mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
    select(White:BlackElo, focal_white) %>% 
    mutate(focal_result = case_when(
      (focal_white == 1 & Result == "1-0") ~ 1,
      (focal_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      )) %>% 
    mutate(focal_win_prop = c(rep(0, prev_n - 1), 
                              roll_mean(focal_result, n = prev_n)))
  
  hist_games
}


head(get_hist(user = curr_user, games = bullet_60, prev_n = 10))

## this seems to be working, then do it across a vector of
## players

```


```{r}
## want to use focal players not all players to get these lists to be the same
a <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 17)
## if don't use all focal players here then removing data because they won't be
## involved


top_players <- names(a)


tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 10) %>% 
  as_tibble()


tidy_games %>% 
  mutate(focal_player = ifelse(focal_white == 1, White, Black)) %>% 
  group_by(focal_player) %>% 
  count() %>% 
  arrange(-n)

## why does this have 17 players rather than 25 then?
## why are some missing?

```


Now need to figure out how to feed this into a Stan model.

```{r}
head(tidy_games)


init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% mutate(ave_prop = focal_win_prop - mean(focal_win_prop))

init_data

### will need
### number of focal players
### which focal player is in each row
### their outcome 0 or 1
### their colour white (1) or black (0)
### ranking diff

```

```{r}

stan_data <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$focal_win_prop)


stan_file <- "model1.stan"

mod <- cmdstan_model(stan_file)

fit1 <- mod$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit1$summary()

## but seems to give positive winner effects for all players
mcmc_hist(fit1$draws("alpha"))
mcmc_hist(fit1$draws("beta"))

# fit$save_object(file = "simple_multi_logistic.RDS")

```



Instead account for the covariates of colour and elo difference also.

```{r}
stan_file <- "model2.stan"

mod <- cmdstan_model(stan_file)

fit2 <- mod$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit2$summary()

mcmc_hist(fit2$draws(c("beta", "gamma1", "gamma2")))

# fit$save_object(file = "cov_multi_logistic.RDS")

## these indicate clear positive coefficients for the betas,
## which are basically winner effects, account for the role
## of win history
## elo seems to have a much smaller role

## repeat for a different history, did this using past 5 games, could try
## others.
## could also compare to longer games, see if you get the same thing
## don't put a common prior on the betas, which is what the Cribben paper
## did. also don't standardize them

```


We can then instead include partial pooling of the $\beta$ coefficients.

```{r}
stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3 <- mod$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)

fit3$summary()
mcmc_hist(fit3$draws(c("beta", "mu", "tau")))


mcmc_trace(fit3$draws(c("mu", "tau", "beta")))

```


## Repeat using normalized win Ratio

```{r}

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model1.stan"

mod <- cmdstan_model(stan_file)

fit1_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit1_ave$summary()

## but seems to give positive winner effects for all players
mcmc_hist(fit1_ave$draws("alpha"))
mcmc_hist(fit1_ave$draws("beta"))

```

```{r}
stan_file <- "model2.stan"

mod <- cmdstan_model(stan_file)

fit2_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit2_ave$summary()

mcmc_hist(fit2$draws(c("beta", "gamma1", "gamma2")))
```

```{r}
stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit3_ave$summary()

mcmc_hist(fit3$draws(c("beta", "mu", "tau", "gamma1", "gamma2")))
```


Given this output, we can get the probability a player who is black
will win against and equally ranked player, when his current win ratio 
is exactly his average will be $1-\exp(-\alpha_j)$ while if they 
are playing as white their win probability will be
$1-\exp(-(\alpha_j + \gamma_1))$, so $\gamma_1$ being positive indicates the win
probability increases when playing white, which makes sense.
Playing white makes a player who has 50% chance of winning as black
have 54% chance of winning with white. Wikipedia says the difference is
4-6% so similar enough.


<!-- ## Streaks -->

<!-- Calculate the length of winning streaks for any given player, -->
<!-- look at how these vary across rankings maybe? -->


```{r}
#| include: false
# get_streaks <- function(games, player_name) {
#   player_games <- games %>% 
#     filter(White == player_name | Black == player_name) 
#   
#   winner <- player_games$
#   ## then get their streaks in here also
# }


peng_games <- bullet_60 %>% 
  filter(White == "penguingim1" | Black == "penguingim1")

peng_games  

peng_games$w <- ifelse(peng_games$Username == peng_games$White, 1, 0)

# result column
peng_games$result <- ifelse(peng_games$w == 1 & peng_games$Result == "1-0" | 
                         peng_games$w == 0 & peng_games$Result == "0-1", 1, 0)


peng_games <- peng_games %>% 
  arrange(UTCDate, UTCTime)


peng_games$result


### then count the streaks in this
## win and loss streaks

wins <- which(peng_games$result == 1)

s <- split(wins, cumsum(c(TRUE, diff(wins) != 1)))
win_streaks <- map_dbl(s, length) %>% as.vector()

## now need to get the losing streaks
losses <- which(peng_games$result == 0)
s <- split(losses, cumsum(c(TRUE, diff(losses) != 1)))

loss_streaks <- map_dbl(s, length) %>% as.vector()

sum(loss_streaks) + sum(win_streaks)

nrow(peng_games)
```


<!-- For a given game, get the proportion of games won by the White player -->
<!-- in their last $n$ games, where we can vary $n$ and see how -->
<!-- changing it changes the results. -->

<!-- - Would you want to count wins as white and/or wins as black then? -->

<!-- - General winner effect -->

<!-- - Pick a player as "focal", look at whether they win or lose, -->
<!-- accounting for their colour, their game history, the ranking  -->
<!-- difference to their opponent, and possibly also the  -->
<!-- titles, which could have some sort of psychological impact on the outcome. -->

```{r}
#| include: false

### get past n results


prev_games <- function(player, hist_len) {
  
}


curr_user <- "penguingim1"

curr_data <- bullet_60 %>% 
  filter(White == curr_user | Black == curr_user)
  
curr_data$w <- ifelse(curr_data$White == curr_user, 1, 0)


## this doesn't account for draws, gives them equal weight to a loss


## one thing you could do is compare results after a draw with
## results after a win or a loss, see how they differ
## if not effect, and control for everything, then they should be the same

curr_data$result <- ifelse(curr_data$w == 1 & curr_data$Result == "1-0" | 
                         curr_data$w == 0 & curr_data$Result == "0-1", 1, 0)


curr_data %>% 
  select(White, Black, WhiteElo, BlackElo, w, result, UTCDate, UTCTime) %>% 
  arrange(UTCDate, UTCTime)

## then use this to get curr win history for curr_user for each game
```




<!-- ## Hot Hand Fallacy -->

<!-- - Potential different probabilities of success in subsequent games,  -->
<!-- i.e depending on who opponent is, black vs white, etc -->

<!-- - Evidence for some individual effects but -->
<!-- not sure if there is anything out there for -->
<!-- Chess already? -->


<!-- ## Some simple Models -->

<!-- - Take previous 10 games, calculate win proportion in those games -->

<!-- - Use this as a predictor for outcome -->

<!-- - Just predict win probability for White, to control for colour -->


<!-- ```{r} -->
<!-- ## logistic regression for win or less based on previous result -->
<!-- ## controlling for opponents ranking, your ranking, colour -->
<!-- ## previous game -->
<!-- ## time since previous game maybe? -->
<!-- ## -->
<!-- ``` -->



<!-- - The tennis stuff maybe and compare it? -->

<!-- - Does how the game ended make a difference? Don't seem to have this for lichess -->

<!-- - Games in tournaments vs rated, other factors like this -->



<!-- ### References -->

<!-- - The hot hand in the wild -->

<!-- - Surprised by the Hot Hand Fallacy? -->
<!-- A Truth in the Law of Small Numbers -->