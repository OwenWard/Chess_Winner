---
title: "Chess EDA"
author: Owen G. Ward
format: 
  html:
    toc: true
    toc-location: left
bibliography: refs.bib
---


```{r setup}
#| include: false

knitr::opts_chunk$set(echo = FALSE, message = FALSE)

library(tidyverse)
library(RcppRoll)
library(cmdstanr)
library(bayesplot)

theme_set(theme_bw())

```



## Data

We first wish to investigate the properties of the scraped data. We 
focus for now on the Lichess data. We see that the vast majority of games in this dataset 
are Standard Chess, with the regular rules, etc. 

```{r}
#| warning: false

lichess_data <- readRDS("../rdata/lichess_pilot.RData")
```



```{r}
#| echo: true
## Variants of Chess in this data
table(lichess_data$Variant)
```
Similarly, the most
commonly played time control, across all formats of chess, is 180+0,
which corresponds to 3 minute blitz games with no time increment.


```{r}
#| echo: true
head(sort(table(lichess_data$TimeControl), decreasing = TRUE))
```

Of standard games, we see that the majority are rated blitz and bullet games.
These correspond to randomly playing available players on the site 
at a given time. This differs from tournaments, which make up a sizeable proportion
of standard games also (and which might have different dynamics).


```{r}
#| echo: true
head(sort(table(lichess_data$Event), decreasing = TRUE))

```


```{r}
#| echo: true

lichess_data %>% filter(Variant == "Standard") %>% 
  group_by(Event) %>% 
  count() %>% 
  arrange(-n) %>% 
  head()

```


The variable `ratingDiff` records how the ELO of both the black and
white player changes based on the outcome of that game.
Here these ELO scores are across the different event types, which
may contain multiple time formats. For example, an ELO for Bullet play will 
change when both 1 minute and 30 second games are played, and also in 
both tournament and rated games.


<!-- Get all games from a specific player in a specific format, -->
<!-- to see that `RatingDiff` tracks how -->
<!-- the rating changes. For the White/Black player based -->
<!-- on the result of the current game. -->

```{r}
#| echo: false
#| eval: false
elo_check <- lichess_data %>% filter(TimeControl == "180+0") %>% 
  filter(Event == "Rated Blitz game") %>% 
  arrange(UTCDate, UTCTime) %>% 
  mutate(peng_elo = ifelse(White == "penguingim1", WhiteElo, BlackElo)) %>% 
  mutate(peng_change = ifelse(White == "penguingim1", WhiteRatingDiff,
                              BlackRatingDiff)) %>% 
  select(UTCDate, UTCTime, peng_elo, peng_change) %>%
  mutate(peng_elo = as.numeric(peng_elo)) %>% 
  mutate(peng_change = as.numeric(peng_change)) %>% 
  mutate(ELO_change = peng_elo + peng_change) 


elo_check %>% 
  mutate(diff = peng_elo - lag(ELO_change))

### so RatingDiff gives you the starting ELO for the next game of the same type

elo_check_2 <- lichess_data %>% 
  filter(Event == "Rated Blitz game") %>% 
  arrange(UTCDate, UTCTime) %>% 
  mutate(peng_elo = ifelse(White == "penguingim1", WhiteElo, BlackElo)) %>% 
  mutate(peng_change = ifelse(White == "penguingim1", WhiteRatingDiff,
                              BlackRatingDiff)) %>% 
  select(UTCDate, UTCTime, peng_elo, peng_change) %>% 
  mutate(peng_elo = as.numeric(peng_elo)) %>% 
  mutate(peng_change = as.numeric(peng_change)) %>% 
  mutate(ELO_change = peng_elo + peng_change) %>% 
  mutate(diff = peng_elo - lag(ELO_change))

elo_check_2

## so these don't always agree, because could play arena games, etc

```

Casual games don't change the rating, so we should probably treat them
differently.
Would likely have a different role in winner effects,
etc. It is possible that Arena and tournament games also have different 
dynamics.


## Initial Models

For the current initial analysis we
will restrict to 1 minute rated bullet games,
the most commonly played format in this dataset, with 13k games compared
to 12k games of 30 second bullet and 12k games of 3 minute blitz.


```{r}
#| echo: true
## get initial dataset to use for analysis


lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  group_by(TimeControl) %>% 
  count() %>% 
  arrange(-n)


bullet_60 <- lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  filter(TimeControl == "60+0")
```

The top 25 players all play at least 80 games in this format, and across 
all games in this format we see relatively few draws. This is unsurprising
as it it hard to end at a draw in these short time controls, when one player
can lose on time.

```{r}
#| echo: true
head(sort(table(c(bullet_60$White, bullet_60$Black)), decreasing = TRUE), 25)


## results of these games
table(bullet_60$Result)

```


### Multilevel Logistic Regression

Similar to @ding2021nhl, we wish to fit a multilevel logistic 
regression to see if we can identify individual 
effects for chess players in this data.
We will incorporate fixed effects for the player effects of the focal
player in these games, along 


We will identify focal players as those who were used to query the API,
i.e the `Username` for each game. We only consider Rated 60 second bullet games
here, and use the top 18 players, who all play at least 100 games
of 1 minute rated bullet chess in this dataset.

We will consider the current history of an individual player
as their win ratio in their past $n$ games, where we will investigate
the sensitivity of these results to different choices of $n$.

As a small percentage (less than 4%) of these games result in 
a draw, we will use these draws to get each players current win history,
before then removing these from the logistic regression model.
Initially we will choose the previous $$n=10$$ games for each player to
compute the win ratio, or the average of all current games if
the historic number of games played is less than 10.


```{r get historic win ratio}

get_hist <- function(user, games, prev_n) {
  hist_games <- games %>% 
    filter(White == user | Black == user) %>% 
    arrange(UTCDate, UTCTime) %>% 
    mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
    select(White:BlackElo, focal_white) %>% 
    mutate(focal_result = case_when(
      (focal_white == 1 & Result == "1-0") ~ 1,
      (focal_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      )) %>% 
    mutate(focal_win_prop = c(cumsum(focal_result[1:(prev_n - 1)])/(1:(prev_n -1)), 
                              roll_mean(focal_result, n = prev_n)))
  hist_games
}


```



```{r, past-n-results}
#| message: false
#| eval: false

## given a players data, determine how many of the previous games they won
## do this for a single player first of all
## only need to do this for the potential focal players

curr_user <- "penguingim1"
curr_n <- 10

curr_games <- bullet_60 %>% 
  filter(White == curr_user | Black == curr_user)


hist_games <- curr_games %>% 
  arrange(UTCDate, UTCTime) %>% 
  mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
  select(White:BlackElo, focal_white)

## need to check all the game types are the same here then
table(curr_games$Variant)
table(curr_games$Result)

## then get the result for curr_user for each game, there will be draws here

user_games <- hist_games %>% 
  mutate(focal_result = case_when(
    (focal_white == 1 & Result == "1-0") ~ 1,
    (focal_white == 0 & Result == "0-1") ~ 1,
    (Result == "1/2-1/2") ~ 0.5,
    .default = 0
    )) %>% 
  mutate(focal_win_prop = c(rep(0, curr_n - 1), roll_mean(focal_result, n = curr_n)))

user_games %>% 
  ggplot(aes(x = focal_win_prop)) +
  geom_histogram(bins = 20) +
  labs(title = "Win Ratio for Previous 10 Games, one Player")

### now just need to get the rolling average of focal result
### need to pad this output

### could we do this using a map across the players of interest,
### get their games and then put it all back together afterwards?
### think that should work, just need to make it into a function then

### modified this so that it calculates rolling averarge of previous n
### games, or all games, when number of previous games is less than n


get_hist <- function(user, games, prev_n) {
  hist_games <- games %>% 
    filter(White == user | Black == user) %>% 
    arrange(UTCDate, UTCTime) %>% 
    mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
    select(White:BlackElo, focal_white) %>% 
    mutate(focal_result = case_when(
      (focal_white == 1 & Result == "1-0") ~ 1,
      (focal_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      )) %>% 
    mutate(focal_win_prop = c(cumsum(focal_result[1:(prev_n - 1)])/(1:(prev_n -1)), 
                              roll_mean(focal_result, n = prev_n)))
  
  hist_games
}


head(get_hist(user = curr_user, games = bullet_60, prev_n = 10))

## this seems to be working, then do it across a vector of
## players



```



We can see the distribution of the win ratio for these 18 players across all
games in this sample.


```{r}
#| message: false

## want to use focal players not all players to get these lists to be the same
focal_players <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 18)
## if don't use all focal players here then removing data because they won't be
## involved

top_players <- names(focal_players)


tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 10) %>% 
  as_tibble()


tidy_games %>% 
  ggplot(aes(focal_win_prop)) +
  geom_histogram() +
  labs(x = "Win Ratio", title = "Previous 10 Games")

```


Removing the drawn games, we have 12500 games involving these 18 focal players.

```{r organize data for stan}

init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = focal_win_prop - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)

nrow(init_data)

```


#### STAN Model

Now we want to fit this multilevel logistic regression. Letting
$y_{ij}$ be the result of the $i$-th game by the $j$-th focal player,
then the model we will consider is

$$
P(y_{ij} = 1) = \frac{1}{1 + \exp(-(\alpha_j + \beta_j x_{ij} + \gamma z_{ij}))}
$$

where:

- $\alpha_j$ is a player level random effect
- $\beta_j$ is a player level random effect, accounting for the win ratio $x_{ij}$
- $\gamma$ is the coefficient of game level coefficients


We then partially pool the $\alpha$ and $\beta$ coefficients, so

$$
\alpha_j \sim \mathcal{N}(\mu_1, \tau_1)
$$
$$
\mu_1 \sim \mathcal{N}(0, 5)
$$
$$
\tau_1 \sim \mathcal{Cauchy}(0, 5)
$$

and similarly


$$
\beta_j \sim \mathcal{N}(\mu_2, \tau_2)
$$
$$
\mu_2 \sim \mathcal{N}(0, 5)
$$
$$
\tau_2 \sim \mathcal{Cauchy}(0, 5)
$$

We rescale the win ratio $x_{ij}$, by the average win ration of
player $j$. This means $\beta_j$ captures how a players win
probability changes as their historic performance deviates from 
the overall average win ratio.

For $z_{ij}$ we incorporate 2 covariates, namely the colour of 
the focal player and the ELO difference between the focal 
player and their opponent. So that means we have 
$\gamma_1$, which tells us how the win probability changes in going
from black to white,
and $\gamma_2$ gives how the win probability changes as the focal player
has a better ELO than their opponent.


```{r fit this model in stan}
#| eval: false

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)

fit3_ave$save_object("init_model_n10.RDS")
```

Some of the output of this model is shown below, namely the empirical posteriors
for each of the parameters.

```{r load in saved fit}
#| message: false

fit3_ave <- readRDS("init_model_n10.RDS")

fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("alpha", "mu2", "tau2")))
mcmc_hist(fit3_ave$draws(c("beta", "mu1", "tau1", "gamma1", "gamma2")))

rhat(fit3_ave)

```


#### Interpreting this output

Given this output, we can get the probability a player who is black
will win against an equally ranked player, when their current win ratio 
is exactly their average will be $\frac{1}{1+\exp(-\alpha_j)}$.
So a positive $\alpha_j$ indicates a player favoured to win 
even when playing black. The overall $\mu_1$ tells us about the 
global probability of winning as black against an equally ranked
opponent.
If a player
is playing as white their win probability will be
$\frac{1}{1+\exp(-(\alpha_j + \gamma_1))}$,
so $\gamma_1$ being positive indicates the win
probability increases when playing white, which makes sense.
Playing white makes a player who has 50% chance of winning as black
have approximately a 54% chance of winning with white. Wikipedia says the increase 
in win probability from playing white has been estimated to be 
4-6% so quite similar.

Similarly, $\gamma_2$ tells us about how the ELO of the focal player 
being larger than their opponent influences their win probability.
The estimate here indicates that a large ELO difference makes a player very
likely to win, as would be expected. For example, a player who
has a 50% chance of winning against an opponent with the same ELO
will have about a 56% of winning against an opponent with an ELO score
100 points lower.

### Varying History

We can refit this using varying numbers of games for the
current win ratio.

```{r 5 prev games}
#| eval: false

tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 5) %>% 
  as_tibble()

init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = focal_win_prop - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit3_ave$save_object("init_model_n5.RDS")

```

```{r}
fit3_ave <- readRDS("init_model_n5.RDS")

fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("beta", "gamma1", "gamma2")))
```


```{r 20 prev games}
#| eval: false

tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 20) %>% 
  as_tibble()

init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = focal_win_prop - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)

## this took 3 minutes

fit3_ave$save_object("init_model_n20.RDS")

```

```{r}

fit3_ave <- readRDS("init_model_n20.RDS")

fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("beta", "mu1","gamma1", "gamma2")))
```


```{r prev 50 games}
#| eval: false

tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 50) %>% 
  as_tibble()

init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = focal_win_prop - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit3_ave$save_object("init_model_n50.RDS")
```


```{r}
#| message: false
fit3_ave <- readRDS("init_model_n50.RDS")

fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("beta", "mu1", "gamma1", "gamma2")))

```


Using a longer history seems to give a model which fits quicker and
is more stable. But I'm not sure why that should be the case?

The size of the winner effects does appear to decrease as you look
at a longer amount of previous games. Unlikely to play more than 
50 games in a row maybe? Still clear positive effects even 
using 50 games.

## Comments

- There are some potential concerns with this Stan model and that it could
be made more efficient and better parameterized. These seem to be a
larger issue when the number of previous games used for the win ratio
is smaller, which would make sense as these would depart more from the mean.

- The size of these winner effects decreases as we look at their win ratio over
more historic games.

- Are there any other variables we should be controlling for here?



```{r}
#| eval: false

stan_data <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$focal_win_prop)


stan_file <- "model1.stan"

mod <- cmdstan_model(stan_file)

fit1 <- mod$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit1$summary()

## but seems to give positive winner effects for all players
mcmc_hist(fit1$draws("alpha"))
mcmc_hist(fit1$draws("beta"))

# fit$save_object(file = "simple_multi_logistic.RDS")

```



```{r}
#| eval: false
stan_file <- "model2.stan"

mod2 <- cmdstan_model(stan_file)

fit2 <- mod2$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit2$summary()

mcmc_hist(fit2$draws(c("beta", "gamma1", "gamma2")))

# fit$save_object(file = "cov_multi_logistic.RDS")

## these indicate clear positive coefficients for the betas,
## which are basically winner effects, account for the role
## of win history
## elo seems to have a much smaller role

## repeat for a different history, did this using past 5 games, could try
## others.
## could also compare to longer games, see if you get the same thing
## don't put a common prior on the betas, which is what the Cribben paper
## did. also don't standardize them

```



```{r}
#| eval: false
stan_file <- "model3.stan"

mod3 <- cmdstan_model(stan_file)

fit3 <- mod3$sample(data = stan_data,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)

fit3$summary()
mcmc_hist(fit3$draws(c("beta", "mu", "tau", "gamma1", "gamma2")))


mcmc_trace(fit3$draws(c("mu", "tau", "beta")))

```



```{r}
#| eval: false
stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "model1.stan"

mod <- cmdstan_model(stan_file)

fit1_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit1_ave$summary()

## but seems to give positive winner effects for all players
mcmc_hist(fit1_ave$draws("alpha"))
mcmc_hist(fit1_ave$draws("beta"))

```

```{r}
#| eval: false
stan_file <- "model2.stan"

mod <- cmdstan_model(stan_file)

fit2_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit2_ave$summary()

mcmc_hist(fit2$draws(c("beta", "gamma1", "gamma2")))
```

```{r}
#| eval: false
stan_file <- "model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("beta", "mu1", "tau1", "gamma1", "gamma2")))
mcmc_hist(fit3_ave$draws(c("alpha", "mu2", "tau2")))
```




<!-- ## Streaks -->

<!-- Calculate the length of winning streaks for any given player, -->
<!-- look at how these vary across rankings maybe? -->


```{r}
#| include: false
# get_streaks <- function(games, player_name) {
#   player_games <- games %>% 
#     filter(White == player_name | Black == player_name) 
#   
#   winner <- player_games$
#   ## then get their streaks in here also
# }


peng_games <- bullet_60 %>% 
  filter(White == "penguingim1" | Black == "penguingim1")

peng_games  

peng_games$w <- ifelse(peng_games$Username == peng_games$White, 1, 0)

# result column
peng_games$result <- ifelse(peng_games$w == 1 & peng_games$Result == "1-0" | 
                         peng_games$w == 0 & peng_games$Result == "0-1", 1, 0)


peng_games <- peng_games %>% 
  arrange(UTCDate, UTCTime)


peng_games$result


### then count the streaks in this
## win and loss streaks

wins <- which(peng_games$result == 1)

s <- split(wins, cumsum(c(TRUE, diff(wins) != 1)))
win_streaks <- map_dbl(s, length) %>% as.vector()

## now need to get the losing streaks
losses <- which(peng_games$result == 0)
s <- split(losses, cumsum(c(TRUE, diff(losses) != 1)))

loss_streaks <- map_dbl(s, length) %>% as.vector()

sum(loss_streaks) + sum(win_streaks)

nrow(peng_games)
```


<!-- For a given game, get the proportion of games won by the White player -->
<!-- in their last $n$ games, where we can vary $n$ and see how -->
<!-- changing it changes the results. -->

<!-- - Would you want to count wins as white and/or wins as black then? -->

<!-- - General winner effect -->

<!-- - Pick a player as "focal", look at whether they win or lose, -->
<!-- accounting for their colour, their game history, the ranking  -->
<!-- difference to their opponent, and possibly also the  -->
<!-- titles, which could have some sort of psychological impact on the outcome. -->

```{r}
#| include: false
#| eval: false

### get past n results


prev_games <- function(player, hist_len) {
  
}


curr_user <- "penguingim1"

curr_data <- bullet_60 %>% 
  filter(White == curr_user | Black == curr_user)
  
curr_data$w <- ifelse(curr_data$White == curr_user, 1, 0)


## this doesn't account for draws, gives them equal weight to a loss


## one thing you could do is compare results after a draw with
## results after a win or a loss, see how they differ
## if not effect, and control for everything, then they should be the same

curr_data$result <- ifelse(curr_data$w == 1 & curr_data$Result == "1-0" | 
                         curr_data$w == 0 & curr_data$Result == "0-1", 1, 0)


curr_data %>% 
  select(White, Black, WhiteElo, BlackElo, w, result, UTCDate, UTCTime) %>% 
  arrange(UTCDate, UTCTime)

## then use this to get curr win history for curr_user for each game
```




<!-- ## Hot Hand Fallacy -->

<!-- - Potential different probabilities of success in subsequent games,  -->
<!-- i.e depending on who opponent is, black vs white, etc -->

<!-- - Evidence for some individual effects but -->
<!-- not sure if there is anything out there for -->
<!-- Chess already? -->


<!-- ## Some simple Models -->

<!-- - Take previous 10 games, calculate win proportion in those games -->

<!-- - Use this as a predictor for outcome -->

<!-- - Just predict win probability for White, to control for colour -->


<!-- ```{r} -->
<!-- ## logistic regression for win or less based on previous result -->
<!-- ## controlling for opponents ranking, your ranking, colour -->
<!-- ## previous game -->
<!-- ## time since previous game maybe? -->
<!-- ## -->
<!-- ``` -->



<!-- - The tennis stuff maybe and compare it? -->

<!-- - Does how the game ended make a difference? Don't seem to have this for lichess -->

<!-- - Games in tournaments vs rated, other factors like this -->



<!-- ### References -->

<!-- - The hot hand in the wild -->

<!-- - Surprised by the Hot Hand Fallacy? -->
<!-- A Truth in the Law of Small Numbers -->