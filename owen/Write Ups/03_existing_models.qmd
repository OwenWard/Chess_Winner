---
title: "Model Checking"
author: Owen G. Ward
date: 05/26/2023
format: 
  # html:
  #   toc: true
  #   toc-location: left
  pdf
bibliography: refs.bib
---

This document will summarise what has been done so far.



```{r setup}
#| include: false

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 8)

library(tidyverse)
library(RcppRoll)
library(cmdstanr)
library(posterior)
library(bayesplot)
library(loo)
library(here)

options(mc.cores = parallel::detectCores())

theme_set(theme_bw())


prob_positive <- function(stan_draws, param = "beta") {
  all_draws <- as_draws_df(stan_draws)
  ndraws <- nrow(all_draws)
  as_tibble(all_draws) %>% 
  select(starts_with(param)) %>% 
  apply(2, function(x) sum(x>0)/ndraws)
}

```


## Initial Models Fit

Based on @ding2021nhl, an initial model proposed was of the form

$$
P(y_{ij} = 1) = \frac{1}{1 + \exp(-(\alpha_j + \beta_j x_{ij} + \gamma z_{ij}))}
$$

where this is the probability of the **j-th focal player** 
winning their **i-th game**. Here:

- $\alpha_j$ is a player level random effect
- $\beta_j$ is a player level random effect, accounting for the win ratio $x_{ij}$
of the focal player over their previous $n$ games
- $\gamma$ is a fixed effect of game level coefficients


We then partially pool the $\alpha$ and $\beta$ coefficients, so

$$
\alpha_j \sim \mathcal{N}(\mu_2, \tau_2)
$$
$$
\mu_2 \sim \mathcal{N}(0, 5)
$$
$$
\tau_2 \sim \mathcal{Cauchy}(0, 5)
$$

and similarly


$$
\beta_j \sim \mathcal{N}(\mu_1, \tau_1)
$$
$$
\mu_1 \sim \mathcal{N}(0, 5)
$$
$$
\tau_1 \sim \mathcal{Cauchy}(0, 5)
$$

We rescale the win ratio $x_{ij}$, by the average win ratio of
player $j$ across all 
games they play in the dataset.
This means $\beta_j$ captures how a players win
probability changes as their historic performance deviates from 
the overall average win ratio.

For $z_{ij}$ we incorporate 2 covariates, namely the colour of 
the focal player and the ELO difference between the focal 
player and their opponent. So that means we have 
$\gamma_1$, which tells us how the win probability changes in going
from black to white,
and $\gamma_2$ gives how the win probability changes as the focal player
has a better ELO than their opponent.

We can show this result, taking the original lichess data
and the 18 players with the most games as focal players.

```{r process data for this model}

lichess_data <- readRDS("../../rdata/lichess_pilot.RData")

lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  group_by(TimeControl) %>% 
  count() %>% 
  arrange(-n)


bullet_60 <- lichess_data %>% 
  filter(Event == "Rated Bullet game") %>% 
  filter(TimeControl == "60+0") %>% 
  mutate(game_id = row_number()) 

```


```{r}
#| eval: false

get_hist <- function(user, games, prev_n) {
  hist_games <- games %>% 
    filter(White == user | Black == user) %>% 
    arrange(UTCDate, UTCTime) %>% 
    mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
    select(White:BlackElo, focal_white) %>% 
    mutate(focal_result = case_when(
      (focal_white == 1 & Result == "1-0") ~ 1,
      (focal_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      )) %>% 
    mutate(focal_win_prop = c(cumsum(focal_result[1:(prev_n - 1)])/(1:(prev_n -1)), 
                              roll_mean(focal_result, n = prev_n)))
  
  hist_games
}

focal_players <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 18)


top_players <- names(focal_players)

tidy_games <- map_dfr(top_players, get_hist, bullet_60, prev_n = 10) %>% 
  as_tibble()


init_data <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = lag(focal_win_prop, default = 0) - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)


```

```{r fit stan model}
#| eval: false

## takes approx 3 minutes on m1 pro mac

stan_data_ave <- list(N = nrow(init_data),
                  J = length(top_players),
                  y = init_data$focal_result,
                  id = init_data$focal_id,
                  colour = init_data$focal_white,
                  elo = init_data$elo_diff,
                  win_prop = init_data$ave_prop)


stan_file <- "../model3.stan"

mod <- cmdstan_model(stan_file)

fit3_ave <- mod$sample(data = stan_data_ave,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)

fit3_ave$save_object("../model_fits/init_model_n10.RDS")
```


```{r load in initial model here}

fit3_ave <- readRDS("../model_fits/init_model_n10.RDS")

# fit3_ave$summary()

mcmc_hist(fit3_ave$draws(c("alpha", "mu2", "tau2")))
mcmc_hist(fit3_ave$draws(c("beta", "mu1", "tau1", "gamma1", "gamma2")))
```

#### Interpreting this output

Given this output, we can get the probability a player who is black
will win against an equally ranked player, when their current win ratio 
is exactly their average will be $\frac{1}{1+\exp(-\alpha_j)}$.
So a positive $\alpha_j$ indicates a player favoured to win 
even when playing black. The overall $\mu_2$ tells us about the 
global probability of winning as black against an equally ranked
opponent, which is just below 0, indicating a slightly less than 50% 
chance of winning.
If a player
is playing as white their win probability will be
$\frac{1}{1+\exp(-(\alpha_j + \gamma_1))}$,
so $\gamma_1$ being positive indicates the win
probability increases when playing white, which makes sense.
Playing white makes a player who has 50% chance of winning as black
have approximately a 54% chance of winning with white. Wikipedia says the increase 
in win probability from playing white has been estimated to be 
4-6% so quite similar.

Similarly, $\gamma_2$ tells us about how the ELO of the focal player 
being larger than their opponent influences their win probability.
The estimate here indicates that a large ELO difference makes a player very
likely to win, as would be expected. For example, a player who
has a 50% chance of winning against an opponent with the same ELO
will have about a 61% chance of winning against an opponent with an ELO score
100 points lower.


#### How big are these effects

We then want to quantify how much these estimated effects change the 
expected win probability.
We have seen the size of the effects above for the non history parameters.
The largest posterior mean for a $\beta\approx 1.56$. Since the normalized win
proportion is between -0.6 and 0.6, that means that for a game
where this player has a 50% chance of winning with a normalized average win
proportion of 0, if their normalized win proportion is 0.5, the
win probability will increase by $\approx 19\%$.
This would occur, for example, if they win 50% of their total games but have
won all 10 of their last 10. This is a similar size effect to the 
increase in win probability which would come from playing an 
opponent with an ELO ranking that is 170 points lower.

Similarly, a normalized win history 0.25 
above average corresponds to a difference 
of approximately 80 in ELO scores.

The underlying parameter $\mu_1$ has posterior mean of 0.606. 
A normalised win history of 0.25 with a winner effect of this size
would increase the win probability by about 4%, a similar effect
as playing as white instead of black, all other covariates being
equal.

#### Winner Effects here

Here, the presence of positive estimates for $\beta$ would indicate the
presence of a __winner/loser__ effect, where a player is performing
better (worse) than their overall performance is more (less)
likely to win their subsequent games. As some of these distributions
take both positive and negative values, we can compute the 
posterior probability that $\beta>0$ for each of the focal players.

```{r prob positive fit3 beta}
#| echo: true
prob_positive(fit3_ave$draws())
```

This indicates that most of these $\beta$ parameters are strongly seen 
as positive.

### Updated Model 

An extension of this model was then to consider the "history" 
as being composed of the previous game and a more general "winning streak",
which is fit by the following model.

$$
P(y_{ij} = 1) = \frac{1}{1 + \exp(-(\alpha_j + \beta_j x_{ij} + 
\delta_j x_{ij}^{*} + 
\gamma z_{ij}))},
$$

where now $x_{ij}^{*}$ is the result of the __previous__ game
played by player $j$, and $x_{ij}$ is their normalised 
win ratio over the previous $n$ games, not including the single
previous game. Note that $x_{ij}^{*}$ is not normalised,
so can take on values $0,0.5,1$.

```{r data for model 2}
#| eval: false

hist_data_init <- tidy_games %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = lag(focal_win_prop, n = 2, default = 0) - 
           mean(focal_win_prop),
         prev_game = lag(focal_result, default = 0)) %>% 
  filter(focal_result != 0.5)


stan_data_hist <- list(N = nrow(hist_data_init),
                  J = length(top_players),
                  y = hist_data_init$focal_result,
                  id = hist_data_init$focal_id,
                  colour = hist_data_init$focal_white,
                  elo = hist_data_init$elo_diff,
                  win_prop = hist_data_init$ave_prop,
                  prev_game = hist_data_init$prev_game)

```


```{r fit the stan model}
#| eval: false

## takes approx 4 minutes on m1 pro mac

stan_file <- "../model4.stan"

mod <- cmdstan_model(stan_file)

fit4 <- mod$sample(data = stan_data_hist,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)


fit4$summary()


fit4$save_object(file = "../model_fits/model4.RDS")
```



```{r load the stan fit}
#| fig-width: 8
#| fig-height: 6

fit4 <- readRDS("../model_fits/model4.RDS")

mcmc_hist(fit4$draws(c("delta", "mu3", "tau3"))) +
  labs(title = "Effect of Previous Game")

mcmc_hist(fit4$draws(c("beta", "mu1", "tau1"))) +
  labs(title = "Effect of Previous n games, excluding most recent game")

```


The $\delta$ parameters then indicate the effect that the previous
game alone has on the next game, while $\beta$ indicates the
effect of the overall current streak (excluding the previous game).

**Should the previous game be normalised to give deviation from average 
performance?**

### Model Checking Comparison

We can use the posterior draws to do some model checking, generating
synthetic data based on the posterior draws. These indicate that 
our models are reasonable and able to describe this data well.
Similarly we can do some model checking which indicates the model
which separates out the history performs substantially better 
than the other model.

## Model from Powerpoint

The slides shared give a similar form of model for this type
of data to estimate winner/loser effects. 
Written in the format shown here, that model would look like

$$
P(y_{Fi} = 1) =\frac{1}{1 + exp(-(\alpha_F + \alpha_{opp_i} + \beta_j\hat{w}_{Fi})
+ \beta_{opp_i}\hat{w}_{Oi} + \delta_j(w_{F,i-1} - \hat{w}_{Fi}) +
\delta_{opp_i}(w_{O,i-1}-\hat{w}_{Oi})))}.
$$

Here we have:

- $\hat{w}_{Fi}, \hat{w}_{Oi}$ is some measure of the long run performance
focal player and their opponent
- $w_{F,i-1} - \hat{w}_{Fi}$ measures the deviation between both players 
previous result and their more long run performance.

One difference with this model is that we now need to consider the 
history of all opponents played by focal players also.
For the chess example where many players are involved, this leads to thousands
of opponents, many who plan only a small number of games.

Covariates could also be included here, as described before.
This model can be fit to the same initial dataset we considered above.


```{r get same data as before for this example}
#| eval: false

get_hist_opp <- function(user, games, prev_n) {
  hist_games <- games %>%
    filter(White == user | Black == user) %>%
    arrange(UTCDate, UTCTime) %>%
    mutate(opp_white = ifelse(user == White, 1, 0)) %>%
    select(White:BlackElo, opp_white, game_id) %>%
    mutate(opp_result = case_when(
      (opp_white == 1 & Result == "1-0") ~ 1,
      (opp_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      ))

  ngames <- nrow(hist_games)

  if(ngames < prev_n) {
    hist_games <- hist_games %>%
    mutate(opp_win_prop = opp_result/(1:ngames))
  }
  else{
    hist_games <- hist_games %>%
      mutate(opp_win_prop = c(cumsum(opp_result[1:(prev_n - 1)])/(1:(prev_n -1)),
                              roll_mean(opp_result, n = prev_n)))
  }
  hist_games$player <- user
  hist_games
}

focal_players <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 18)
## if don't use all focal players here then removing data because they won't be
## involved

top_players <- names(focal_players)

kept_games <- bullet_60 %>% 
  filter(Username %in% top_players) %>% 
  select(White:BlackElo, Username, game_id) %>%
  mutate(opponent = ifelse(Username == White, Black, White),
         focal_white = ifelse(Username == White, 1, 0))

curr_players <- unique(c(kept_games$White, kept_games$Black))

all_hist <- map_dfr(curr_players, get_hist_opp, bullet_60, prev_n = 10) %>%
  as_tibble() %>%
  select(game_id:player, UTCDate, UTCTime)

min_hist <- all_hist %>% select(game_id:player)

tidy_stan <- kept_games %>%
  left_join(min_hist, by = c("game_id", "Username" = "player")) %>%
  arrange(UTCDate, UTCTime) %>%
  rename(focal_result = opp_result, focal_win_prop = opp_win_prop) %>%
  left_join(min_hist, by = c("game_id", "opponent" = "player")) %>%
  as_tibble()

player_avg <- all_hist %>%
  group_by(player) %>%
  arrange(UTCDate, UTCTime, .by_group = TRUE) %>%
  mutate(nrow = row_number()) %>%
  mutate(curr_avg = cumsum(opp_result)/nrow) %>%
  select(game_id, player, curr_avg)

global_avg <- all_hist %>%
  group_by(player) %>%
  summarise(total_avg = mean(opp_result))

```



```{r prep this for the stan model}
#| eval: false

final_data <- tidy_stan %>%
  left_join(player_avg, by = c("Username" = "player", "game_id")) %>%
  rename(focal_avg = curr_avg) %>%
  left_join(player_avg, by = c("opponent" = "player", "game_id")) %>%
  rename(opp_avg = curr_avg) %>%
  group_by(Username) %>%
  arrange(UTCDate, UTCTime, .by_group = TRUE) %>%
  mutate(focal_prev_result = lag(focal_result, default = 0),
         focal_runn_avg = lag(focal_win_prop, n = 2, default = 0)) %>%
  ungroup() %>%
  group_by(opponent) %>%
  arrange(UTCDate, UTCTime, .by_group = TRUE) %>%
  mutate(opp_prev_result = lag(opp_result, default = 0),
         opp_runn_avg = lag(opp_win_prop, n = 2, default = 0)) %>%
  ungroup() %>%
  mutate(focal_id = match(Username, curr_players),
         opp_id = match(opponent, curr_players)) %>%
  filter(focal_result != 0.5) %>%
  select(-focal_avg, - opp_avg, - opp_result,
         - focal_win_prop, - opp_win_prop) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, as.numeric(WhiteElo) - 
                             as.numeric(BlackElo), 
                           as.numeric(BlackElo) - as.numeric(WhiteElo)))

final_data

## now running average is based on the previous 10 games, not all previous games

```


```{r process for stan and fit}
#| eval: false

stan_data_all <- list(N = nrow(final_data),
                      J = length(curr_players),
                      y = final_data$focal_result,
                      focal_id = final_data$focal_id,
                      opp_id = final_data$opp_id,
                      focal_prev = final_data$focal_prev_result,
                      opp_prev = final_data$opp_prev_result,
                      focal_avg = final_data$focal_runn_avg,
                      opp_avg = final_data$opp_runn_avg,
                      elo_diff = final_data$elo_diff,
                      colour = final_data$focal_white)

saveRDS(stan_data_all, file = "../cluster_scripts/stan_data_ppt_n10.RDS")

stan_data_all <- readRDS("../cluster_scripts/stan_data_ppt_n10.RDS")
### this takes several hours, needs to be run on a cluster

stan_file <- "../Comp3.stan"

mod2 <- cmdstan_model(stan_file)

fit2 <- mod2$sample(data = stan_data_all,
                    seed = 123,
                    chains = 4,
                    parallel_chains = 4,
                    refresh = 100,
                    iter_sampling = 500,
                    iter_warmup = 100)


```


```{r plot some parts of this model}
#| fig-height: 5
#| fig-cap: Player effects for the 18 players considered by the previous model.

## estimated effects for the focal players
## posterior predictive checks 

fit_ppt <- readRDS(here("owen", "cluster_scripts",
                        "Cluster_stan_ppt_2_n10_June5.RDS"))

focal <- paste0("alpha[", c(1, 127, 1207, 1263, 1519, 1635, 
                           1789, 2084, 2139, 2441, 2503, 2561, 
                           2679, 2707, 2781, 2836, 3533, 3714), "]")

mcmc_hist(fit_ppt$draws(focal))

## most of these alphas centered around 0, 1/2 slightly positive and
## 1/2 slightly negative. these player effects

```


```{r}
#| fig-height: 5
#| fig-cap: Longer run (10 game) winner effects for those 18 players.

focal <- paste0("beta[", c(1, 127, 1207, 1263, 1519, 1635, 
                           1789, 2084, 2139, 2441, 2503, 2561, 
                           2679, 2707, 2781, 2836, 3533, 3714), "]")

mcmc_hist(fit_ppt$draws(focal))

## some of these betas not 0 really, this is more interesting maybe
## beta corresponds to the long run effect (prev 10 games)

```



```{r}
#| fig-height: 5
#| fig-cap: Effect of deviation in previous game from previous 10.

focal_gamma <- paste0("gamma[", c(1, 127, 1207, 1263, 1519, 1635, 
                           1789, 2084, 2139, 2441, 2503, 2561, 
                           2679, 2707, 2781, 2836, 3533, 3714), "]")


mcmc_hist(fit_ppt$draws(focal_gamma))

## some of these slightly positive or negative, but not much
## this corresponds to previous game deviation from prev 10 games

```


```{r}
#| fig-height: 5
#| fig-cap: The global parameters for this model.


mcmc_hist(fit_ppt$draws(c("mu1", "mu2", "mu3",
                          "tau1", "tau2", "tau3")))

```

![Predictive Checks](../cluster_scripts/ppd_model2_June5.png)

This model gives similar predictive performance to the previously proposed
model. 



## Questions, Comments


- The choice of the focal player for these types of models. Is there a
way this should be done?

- I think that you probably do need to include the history of 
both players in a match. Otherwise could identify a winner effect for the
focal player which is actually a loser effect for the opponent. However,
it may not be practical to have a separate effect for all players in a
given dataset.

- Need to think some more about what to normalize and how important
that is for models of this form.

- How do these winner effects vary with the rating of players,
and how their rating changes over time?


```{r}

focal_players <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 18)
## if don't use all focal players here then removing data because they won't be
## involved

top_players <- names(focal_players)

kept_games <- bullet_60 %>% 
  filter(Username %in% top_players) %>% 
  select(White:BlackElo, Username, game_id) %>%
  mutate(opponent = ifelse(Username == White, Black, White),
         focal_white = ifelse(Username == White, 1, 0))

curr_players <- unique(c(kept_games$White, kept_games$Black))

## note that rhat(fit_ppt) should work, just too big here

white <- bullet_60 %>% 
  select(game_id, White, WhiteElo) %>% 
  rename(Player = White, ELO = WhiteElo)

black <- bullet_60 %>% 
  select(game_id, Black, BlackElo) %>% 
  rename(Player = Black, ELO = BlackElo)

game_elo <- bind_rows(white, black)

avg_ELO <- game_elo %>% 
  mutate(ELO = as.numeric(ELO)) %>% 
  group_by(Player) %>% 
  summarise(mean_rating = mean(ELO))

## need to order these correctly, based on the indexing used for stan

player_info <- tibble(Player = curr_players) %>% 
  mutate(id = row_number())

avg_ELO <- avg_ELO %>% 
  left_join(player_info, by = "Player") %>% 
  drop_na()
  

## then get the posterior means for each of the parameters for this.

alpha_draws <- as_draws_df(fit_ppt$draws(c("alpha")))
beta_draws <- as_draws_df(fit_ppt$draws(c("beta")))
gamma_draws <- as_draws_df(fit_ppt$draws(c("gamma")))

alpha_mean <- apply(alpha_draws, 2, mean)
beta_mean <- apply(beta_draws, 2, mean)
gamma_mean <- apply(gamma_draws, 2, mean)
## then get the id's from this, based on the names
# names(alpha_mean)

coef_info <- tibble(mean_alpha = alpha_mean, 
                    mean_beta = beta_mean,
                    mean_gamma = gamma_mean) %>% 
  mutate(id = row_number())


avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  ggplot(aes(mean_alpha, mean_rating)) +
  geom_point() + 
  labs(x = "Posterior Mean for Alpha", y = "Mean ELO")


avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  ggplot(aes(mean_beta, mean_rating)) +
  geom_point() + 
  labs(x = "Posterior Mean for Beta", y = "Mean ELO")


avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  ggplot(aes(mean_gamma, mean_rating)) +
  geom_point() + 
  labs(x = "Posterior Mean for Gamma", y = "Mean ELO")


top_id <- c(1, 127, 1207, 1263, 1519, 1635, 
                           1789, 2084, 2139, 2441, 2503, 2561, 
                           2679, 2707, 2781, 2836, 3533, 3714)

avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  mutate(top = ifelse(id %in% top_id, "TOP", "REST")) %>% 
  ggplot(aes(mean_alpha, mean_rating, colour = top)) +
  geom_point() + 
  labs(x = "Posterior Mean for Alpha", y = "Mean ELO")

avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  mutate(top = ifelse(id %in% top_id, "TOP", "REST")) %>% 
  ggplot(aes(mean_beta, mean_rating, colour = top)) +
  geom_point() + 
  labs(x = "Posterior Mean for Beta", y = "Mean ELO")

avg_ELO %>% 
  left_join(coef_info, by = "id") %>% 
  mutate(top = ifelse(id %in% top_id, "TOP", "REST")) %>% 
  ggplot(aes(mean_gamma, mean_rating, colour = top)) +
  geom_point() + 
  labs(x = "Posterior Mean for Gamma", y = "Mean ELO")

## this just gives you the players who play few games all lumped together 
## basically, which makes sense

```


## Updates July

Only consider a single game in each window?


```{r}

get_hist_mod <- function(user, games, prev_n) {
  hist_games <- games %>% 
    filter(White == user | Black == user) %>% 
    arrange(UTCDate, UTCTime) %>% 
    mutate(focal_white = ifelse(Username == White, 1, 0)) %>% 
    select(White:BlackElo, focal_white) %>% 
    mutate(focal_result = case_when(
      (focal_white == 1 & Result == "1-0") ~ 1,
      (focal_white == 0 & Result == "0-1") ~ 1,
      (Result == "1/2-1/2") ~ 0.5,
      .default = 0
      )) %>% 
    mutate(focal_win_prop = c(cumsum(focal_result[1:(prev_n - 1)])/(1:(prev_n -1)), 
                              roll_mean(focal_result, n = prev_n)),
           window_id = row_number()/prev_n)
  
  hist_games %>% filter(window_id - round(window_id) == 0)
}


focal_players <- head(sort(table(c(bullet_60$Username)), decreasing = TRUE), 18)


top_players <- names(focal_players)

tidy_games_mod <- map_dfr(top_players, get_hist_mod, bullet_60, prev_n = 10) %>% 
  as_tibble()

## so this takes windows of size 10, so keep 10th game, 
## use history from the previous 9 games each time

tidy_games_mod


init_data_mod <- tidy_games_mod %>% 
  mutate(WhiteElo = as.numeric(WhiteElo), 
         BlackElo = as.numeric(BlackElo)) %>% 
  mutate(focal_user = ifelse(focal_white == 1, White, Black)) %>% 
  mutate(elo_diff = ifelse(focal_white == 1, 
                           WhiteElo - BlackElo, BlackElo - WhiteElo)) %>% 
  mutate(focal_id = match(focal_user, top_players)) %>% 
  select(focal_user, focal_id, focal_white, 
         focal_win_prop, elo_diff, focal_result) %>% 
  group_by(focal_id) %>% 
  mutate(ave_prop = lag(focal_win_prop, default = 0) - mean(focal_win_prop)) %>% 
  filter(focal_result != 0.5)

```

Then quickly fit model to this data.


```{r}
stan_data_mod <- list(N = nrow(init_data_mod),
                  J = length(top_players),
                  y = init_data_mod$focal_result,
                  id = init_data_mod$focal_id,
                  colour = init_data_mod$focal_white,
                  elo = init_data_mod$elo_diff,
                  win_prop = init_data_mod$ave_prop)


stan_file <- "../model3.stan"

mod <- cmdstan_model(stan_file)

fit3_mod <- mod$sample(data = stan_data_mod,
                  seed = 123,
                  chains = 4,
                  parallel_chains = 4,
                  refresh = 100)
```

```{r}
fit3_mod$summary()


mcmc_hist(fit3_mod$draws(c("beta", "mu1", "tau1", "gamma1", "gamma2")))
```

Get the posterior predictive checks.

```{r}
fit_samples <- as_draws_df(fit3_mod$draws())


fit_samp <- fit_samples %>% 
  select(!starts_with(c("log_lik", "yrep")))


y_rep <- fit_samples %>% select(starts_with("y_rep"))

rm(fit_samples)
rm(fit_samp)

### then want to join this with the correct input, i.e player, etc


y_rep_mod <- y_rep %>% 
  rownames_to_column() %>%  
  pivot_longer(-rowname) %>% 
  pivot_wider(names_from=rowname, values_from=value) %>% 
  ## remove the draws and chains here
  mutate(focal_id = stan_data_mod$id)

games_won <- y_rep_mod %>% 
  pivot_longer(cols = `1`:`4000`, names_to = "draw", values_to = "y") %>% 
  group_by(focal_id, draw) %>% 
  summarise(games_won = sum(y)) 

orig_data <- tibble(outcome = stan_data_mod$y,
                    focal_id = stan_data_mod$id)

orig_games_won <- orig_data %>% 
  group_by(focal_id) %>% 
  summarise(games_won = sum(outcome))


games_won %>% 
  ggplot(aes(x = games_won)) +
  geom_histogram(bins = 20) +
  facet_wrap(~focal_id, scales = "free") +
  geom_vline(data = orig_games_won, 
             mapping = aes(xintercept = games_won), col = "red") +
  labs(title = "Final Outcome in Window Only") 

```

